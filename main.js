/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// i18n.ts
function initializeLanguage(userPreference) {
  var _a;
  if (userPreference) {
    currentLanguage = userPreference;
    return;
  }
  const systemLang = navigator.language || ((_a = navigator.languages) == null ? void 0 : _a[0]);
  if (systemLang == null ? void 0 : systemLang.startsWith("ru")) {
    currentLanguage = "ru";
  } else {
    currentLanguage = "en";
  }
}
function setLanguage(language) {
  currentLanguage = language;
}
function getSupportedLanguages() {
  return [
    { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "en", name: "English" }
  ];
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`Translation key not found: ${key}`);
      return key;
    }
  }
  return typeof value === "string" ? value : key;
}
function tWithParams(key, params) {
  let translation = t(key);
  for (const [paramKey, paramValue] of Object.entries(params)) {
    translation = translation.replace(
      new RegExp(`\\{${paramKey}\\}`, "g"),
      String(paramValue)
    );
  }
  return translation;
}
var ru, en, translations, currentLanguage;
var init_i18n = __esm({
  "i18n.ts"() {
    ru = {
      common: {
        ok: "\u041E\u041A",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
        loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
        error: "\u041E\u0448\u0438\u0431\u043A\u0430",
        success: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E"
      },
      modals: {
        searchTitle: "\u{1F37F} \u041F\u043E\u0438\u0441\u043A \u0430\u043A\u0442\u0435\u0440\u0430",
        searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u043A\u043B\u044E\u0447\u0435\u0432\u043E\u043C\u0443 \u0441\u043B\u043E\u0432\u0443",
        searchButton: "\u041D\u0430\u0439\u0442\u0438",
        searching: "\u041F\u043E\u0438\u0441\u043A...",
        enterMovieName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043C\u044F \u0430\u043A\u0442\u0435\u0440\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        needApiToken: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        loadingMovieInfo: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E\u0431 \u0430\u043A\u0442\u0435\u0440\u0435...",
        preparingImages: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
        movieInfoLoaded: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0430\u043A\u0442\u0435\u0440\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430!",
        errorMovieData: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0430\u043A\u0442\u0435\u0440\u0430",
        errorUnexpected: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430",
        errorGettingDetails: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043E \u0430\u043A\u0442\u0435\u0440\u0435",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0433\u0435\u043E\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0430)",
        posterTooltipMissing: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442",
        posterTooltipEmptyLink: "\u041F\u0443\u0441\u0442\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
        posterTooltipInvalidLink: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440"
      },
      suggesters: {
        fileListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432:",
        folderListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u043F\u0430\u043F\u043E\u043A:"
      },
      validation: {
        invalidApiToken: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        invalidSearchQuery: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441",
        invalidMovieId: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        invalidPaginationParams: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043F\u0430\u0433\u0438\u043D\u0430\u0446\u0438\u0438"
      },
      provider: {
        tokenRequired: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        enterMovieTitle: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        nothingFound: '\u041F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443 "{query}" \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.',
        invalidMovieId: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        tokenRequiredForMovie: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        movieInfoError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
        tryChangeQuery: "\u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441."
      },
      errorHandler: {
        badRequest: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.",
        unauthorized: "\u041D\u0435\u0430\u0432\u0442\u043E\u0440\u0438\u0437\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043E\u0441\u0442\u0443\u043F. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E API \u0442\u043E\u043A\u0435\u043D \u0443\u043A\u0430\u0437\u0430\u043D \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D.",
        forbidden: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u0441\u0443\u0442\u043E\u0447\u043D\u044B\u0439 \u043B\u0438\u043C\u0438\u0442. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        notFound: "\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441.",
        tooManyRequests: "\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u043E\u0432. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        internalServerError: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        badGateway: "\u0421\u0435\u0440\u0432\u0435\u0440 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (502 Bad Gateway).",
        serviceUnavailable: "\u0421\u0435\u0440\u0432\u0438\u0441 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443 \u043F\u043E\u0437\u0436\u0435.",
        gatewayTimeout: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043D\u0435 \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442. \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (504 Gateway Timeout).",
        networkError: "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C \u043A \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435.",
        unknownStatusError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 (\u043A\u043E\u0434 {status}). \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        unexpectedError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435."
      },
      images: {
        poster: "\u043F\u043E\u0441\u0442\u0435\u0440\u0430",
        noImagesToDownload: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F",
        downloading: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435",
        downloadingPoster: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0441\u0442\u0435\u0440\u0430...",
        completed: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
        completedAllDownloaded: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0412\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0441\u043A\u0430\u0447\u0430\u043D\u044B",
        completedAlreadyLocal: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0443\u0436\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0435",
        completedWithErrors: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0423\u0441\u043F\u0435\u0448\u043D\u043E: {successful}, \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C: {failed}",
        invalidUrl: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 URL: {url}. \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 HTTP/HTTPS URL.",
        imageNotFound: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E (404): {url}",
        accessForbidden: "\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D (403): {url}",
        serverError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435: {url}",
        timeout: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435 {timeout}\u043C\u0441",
        downloadedWithErrors: "\u0421\u043A\u0430\u0447\u0430\u043D\u043E: {successful}/{total} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439. \u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435.",
        imagesUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442\u0441\u044F \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438.",
        processingError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        posterUnavailable: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        coverUnavailable: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        logoUnavailable: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        downloadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C"
      },
      utils: {
        unknownMovie: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u043C",
        copyPrefix: "\u041A\u043E\u043F\u0438\u044F",
        templateNotFound: "\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        templateReadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430"
      },
      settings: {
        apiToken: "API \u0422\u043E\u043A\u0435\u043D",
        apiTokenDesc: "\u0412\u0430\u043C \u043D\u0443\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u0430. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0438 \u0441\u043B\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u044F\u043C.",
        getApiToken: "\u041F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0422\u043E\u043A\u0435\u043D",
        checkToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D",
        checking: "\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C...",
        tokenValid: "\u2705 \u0422\u043E\u043A\u0435\u043D \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D!",
        tokenInvalid: "\u274C \u0422\u043E\u043A\u0435\u043D \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u0430.",
        tokenError: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u0442\u043E\u043A\u0435\u043D\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        enterToken: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
        imagesHeading: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
        saveImagesLocally: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E",
        saveImagesLocallyDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043E\u043A.",
        imagesFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        imagesFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0441\u043A\u0430\u0447\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
        imagesFolderPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: attachments/kinopoisk",
        savePosterImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B",
        savePosterImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        moviesHeading: "\u0410\u043A\u0442\u0435\u0440\u044B",
        movieFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0430\u043A\u0442\u0435\u0440\u0430",
        movieFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0435\u0440\u043E\u0432.",
        movieFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
        movieFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0430\u043A\u0442\u0435\u0440\u043E\u0432",
        movieFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E\u0431 \u0430\u043A\u0442\u0435\u0440\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
        movieFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
        movieTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0435\u0440\u043E\u0432",
        movieTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
        movieTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
        exampleTemplate: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
        OnFileCreatedTrigerName: "\u0410\u0432\u0442\u043E\u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0430\u043A\u0442\u0435\u0440\u0430",
        OnFileCreatedTrigerDesc: "\u0410\u0432\u0442\u043E\u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0430\u043A\u0442\u0435\u0440\u0430 \u043F\u0440\u0438 \u043F\u0435\u0440\u0435\u0445\u043E\u0434\u0435 \u043F\u043E \u0441\u0441\u044B\u043B\u043A\u0435, \u0432 \u0444\u0438\u043B\u044C\u043C\u0435/c\u0435\u0440\u0438\u0430\u043B\u0435",
        language: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
        languageDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430."
      }
    };
    en = {
      common: {
        ok: "OK",
        cancel: "Cancel",
        save: "Save",
        loading: "Loading...",
        error: "Error",
        success: "Success"
      },
      modals: {
        searchTitle: "\u{1F37F} Search movie or TV show",
        searchPlaceholder: "Search by keyword",
        searchButton: "Search",
        searching: "Searching...",
        enterMovieName: "Enter movie or TV show name to search",
        needApiToken: "API token must be specified in plugin settings",
        loadingMovieInfo: "Loading movie information...",
        preparingImages: "Preparing to download images...",
        movieInfoLoaded: "Movie information loaded!",
        errorMovieData: "Error: invalid movie data",
        errorUnexpected: "An unexpected error occurred",
        errorGettingDetails: "An unexpected error occurred while getting movie information",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "Poster unavailable (possibly geo-blocked)",
        posterTooltipMissing: "Poster missing",
        posterTooltipEmptyLink: "Empty poster link",
        posterTooltipInvalidLink: "Invalid poster link"
      },
      suggesters: {
        fileListError: "Error getting file list:",
        folderListError: "Error getting folder list:"
      },
      validation: {
        invalidApiToken: "Invalid API token",
        invalidSearchQuery: "Invalid search query",
        invalidMovieId: "Invalid movie ID",
        invalidPaginationParams: "Invalid pagination parameters"
      },
      provider: {
        tokenRequired: "Valid API token must be specified in plugin settings",
        enterMovieTitle: "Enter movie or TV show title to search",
        nothingFound: 'Nothing found for query "{query}".',
        invalidMovieId: "Invalid movie ID",
        tokenRequiredForMovie: "Valid API token must be specified",
        movieInfoError: "Failed to get movie information",
        tryChangeQuery: "Try changing the search query."
      },
      errorHandler: {
        badRequest: "Bad request. Please check the entered data.",
        unauthorized: "Unauthorized access. Make sure the API token is specified and valid.",
        forbidden: "Daily limit exceeded. Please wait and try again.",
        notFound: "Data not found. Try changing the search query.",
        tooManyRequests: "Too many requests. Please wait a bit and try again.",
        internalServerError: "Kinopoisk server internal error. Try again later.",
        badGateway: "Kinopoisk server temporarily unavailable (502 Bad Gateway).",
        serviceUnavailable: "Service temporarily unavailable. Try again later.",
        gatewayTimeout: "Server not responding. Timeout exceeded (504 Gateway Timeout).",
        networkError: "Internet connection problems. Check your connection.",
        unknownStatusError: "An error occurred when requesting the server (code {status}). Try again later.",
        unexpectedError: "An unexpected error occurred during the request. Try again later."
      },
      images: {
        poster: "poster",
        noImagesToDownload: "No images to download",
        downloading: "Downloading",
        downloadingPoster: "Downloading poster...",
        completed: "Completed!",
        completedAllDownloaded: "Completed! All images downloaded",
        completedAlreadyLocal: "Completed! Images are already local",
        completedWithErrors: "Completed! Successful: {successful}, failed: {failed}",
        invalidUrl: "Invalid URL format: {url}. Expected valid HTTP/HTTPS URL.",
        imageNotFound: "Image not found (404): {url}",
        accessForbidden: "Access forbidden (403): {url}",
        serverError: "Server error ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "Failed to download image: {url}",
        timeout: "Timeout after {timeout}ms",
        downloadedWithErrors: "Downloaded: {successful}/{total} images. Some are unavailable in your region.",
        imagesUnavailable: "Images are unavailable in your region. Using original links.",
        processingError: "Error processing images",
        posterUnavailable: "Poster unavailable (possibly blocked in your region)",
        coverUnavailable: "Cover unavailable (possibly blocked in your region)",
        logoUnavailable: "Logo unavailable (possibly blocked in your region)",
        downloadError: "Failed to download"
      },
      utils: {
        unknownMovie: "Unknown Movie",
        copyPrefix: "Copy",
        templateNotFound: "Template not found",
        templateReadError: "Failed to read template file"
      },
      settings: {
        apiToken: "API Token",
        apiTokenDesc: "You need to get API token to use this plugin. Choose free plan and follow steps.",
        getApiToken: "Get API Token",
        checkToken: "Check Token",
        checking: "Checking...",
        tokenValid: "\u2705 Token is valid!",
        tokenInvalid: "\u274C Token is invalid. Please check your token.",
        tokenError: "\u274C Error checking token. Please try again later.",
        enterToken: "Enter API token to check",
        imagesHeading: "Images",
        saveImagesLocally: "Save images locally",
        saveImagesLocallyDesc: "Download and save images to local folder instead of using web URLs.",
        imagesFolder: "Images folder",
        imagesFolderDesc: "Folder where downloaded images will be saved.",
        imagesFolderPlaceholder: "Example: attachments/kinopoisk",
        savePosterImage: "Save poster images",
        savePosterImageDesc: "Download and save actor poster images.",
        moviesHeading: "Movies",
        movieFileName: "Movie file name",
        movieFileNameDesc: "Enter the movie file name format.",
        movieFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
        movieFileLocation: "Movie file location",
        movieFileLocationDesc: "New movie notes will be placed here.",
        movieFileLocationPlaceholder: "Example: folder1/folder2",
        movieTemplateFile: "Movie template file",
        movieTemplateFileDesc: "Files will be available as templates.",
        movieTemplateFilePlaceholder: "Example: templates/template-file",
        exampleTemplate: "Example Template",
        OnFileCreatedTrigerName: "Auto-creation of an actor's note",
        OnFileCreatedTrigerDesc: "Auto-creation of an actor's note when clicking on a link, in a movie/TV series",
        language: "Interface language",
        languageDesc: "Select the plugin interface language."
      }
    };
    translations = {
      ru,
      en
    };
    currentLanguage = "en";
  }
});

// Utils/utils.ts
function replaceIllegalFileNameCharactersInString(text) {
  if (!text) {
    return "";
  }
  return text.replace(/[\\/:*?"<>|]/g, "");
}
function getPlainValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = value[0];
      if (typeof firstValue === "string") {
        return firstValue.replace(/^"(.*)"$/, "$1");
      }
      return firstValue != null ? firstValue : "";
    }
    return value.filter((item) => item != null).map((item) => {
      if (typeof item === "string") {
        return item.replace(/^"(.*)"$/, "$1");
      }
      return String(item);
    }).join(", ");
  }
  if (typeof value === "number") {
    return value;
  }
  return String(value || "");
}
function getQuotedValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = String(value[0] || "");
      if (firstValue.startsWith("![[") || firstValue.startsWith("![](")) {
        if (!firstValue.startsWith('"') && !firstValue.endsWith('"')) {
          return `"${firstValue}"`;
        }
      }
      if (firstValue.startsWith('"') && firstValue.endsWith('"')) {
        const innerText = firstValue.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return firstValue;
    }
    return value.filter((item) => item != null).map((item) => {
      const itemStr = String(item);
      if (itemStr.startsWith("![[") || itemStr.startsWith("![](")) {
        if (!itemStr.startsWith('"') && !itemStr.endsWith('"')) {
          return `"${itemStr}"`;
        }
      }
      if (itemStr.startsWith('"') && itemStr.endsWith('"')) {
        const innerText = itemStr.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return itemStr;
    }).join(", ");
  }
  const stringValue = String(value || "");
  if (stringValue.startsWith('"') && stringValue.endsWith('"')) {
    const innerText = stringValue.slice(1, -1);
    const escapedInnerText = innerText.replace(/"/g, '\\"');
    return `"${escapedInnerText}"`;
  }
  return stringValue;
}
function replaceVariableSyntax(movieShow, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  try {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = text.match(frontmatterRegex);
    if (match) {
      const [, frontmatter, body] = match;
      const processedFrontmatter = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const quotedValue = getQuotedValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              quotedValue
            );
          } catch (error) {
            console.error(
              `Error processing frontmatter variable ${key}:`,
              error
            );
            return result2;
          }
        },
        frontmatter
      );
      const processedBody = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const plainValue = getPlainValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              String(plainValue)
            );
          } catch (error) {
            console.error(
              `Error processing body variable ${key}:`,
              error
            );
            return result2;
          }
        },
        body
      );
      const result = `---
${processedFrontmatter}
---
${processedBody}`;
      return result.replace(/{{\w+}}/gi, "").trim();
    } else {
      const entries = Object.entries(movieShow);
      return entries.reduce((result, [key, val = ""]) => {
        try {
          const plainValue = getPlainValueFromArray(val);
          return result.replace(
            new RegExp(`{{${key}}}`, "ig"),
            String(plainValue)
          );
        } catch (error) {
          console.error(
            `Error processing variable ${key}:`,
            error
          );
          return result;
        }
      }, text).replace(/{{\w+}}/gi, "").trim();
    }
  } catch (error) {
    console.error("Error in replaceVariableSyntax:", error);
    return text;
  }
}
async function makeFileName(app, movieShow, fileNameFormat, folderPath) {
  try {
    let baseName;
    if (fileNameFormat) {
      baseName = replaceVariableSyntax(movieShow, fileNameFormat);
    } else {
      baseName = movieShow.nameForFile || t("utils.unknownMovie");
    }
    const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
    if (!cleanedBaseName.trim()) {
      return `${t("utils.unknownMovie")}.md`;
    }
    const fileName = cleanedBaseName + ".md";
    const { vault } = app;
    const fullPath = folderPath ? `${folderPath}/${fileName}` : fileName;
    const normalizedPath = (0, import_obsidian3.normalizePath)(fullPath);
    if (!vault.getAbstractFileByPath(normalizedPath)) {
      return fileName;
    }
    let copyNumber = 1;
    let copyFileName;
    let copyFullPath;
    do {
      copyFileName = `${cleanedBaseName} (${t(
        "utils.copyPrefix"
      )}[${copyNumber}]).md`;
      copyFullPath = folderPath ? `${folderPath}/${copyFileName}` : copyFileName;
      copyNumber++;
    } while (vault.getAbstractFileByPath((0, import_obsidian3.normalizePath)(copyFullPath)));
    return copyFileName;
  } catch (error) {
    console.error("Error creating file name:", error);
    return `${t("utils.unknownMovie")}.md`;
  }
}
async function getTemplateContents(app, templatePath) {
  if (!templatePath || templatePath === "/") {
    return "";
  }
  try {
    const { metadataCache, vault } = app;
    const normalizedTemplatePath = (0, import_obsidian3.normalizePath)(templatePath);
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    if (!templateFile) {
      console.warn(
        `${t("utils.templateNotFound")}: ${normalizedTemplatePath}`
      );
      return "";
    }
    return await vault.cachedRead(templateFile);
  } catch (error) {
    console.error(`Failed to read the template '${templatePath}':`, error);
    new import_obsidian3.Notice(t("utils.templateReadError"));
    return "";
  }
}
var import_obsidian3;
var init_utils = __esm({
  "Utils/utils.ts"() {
    import_obsidian3 = require("obsidian");
    init_i18n();
  }
});

// Utils/imageUtils.ts
var imageUtils_exports = {};
__export(imageUtils_exports, {
  downloadAndSaveImage: () => downloadAndSaveImage,
  processImages: () => processImages
});
function isValidImageUrl(url) {
  if (!url || url.trim() === "") return false;
  try {
    new URL(url);
    return url.startsWith("http://") || url.startsWith("https://");
  } catch (e) {
    return false;
  }
}
function getImageExtension(url, mimeType) {
  var _a;
  if (mimeType && MIME_TO_EXTENSION_MAP[mimeType]) {
    return MIME_TO_EXTENSION_MAP[mimeType];
  }
  const urlExtension = (_a = url.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  if (urlExtension && SUPPORTED_EXTENSIONS.includes(urlExtension)) {
    return urlExtension;
  }
  return "jpg";
}
function createImageFileName(movieShow, imageType, extension) {
  const baseName = `${movieShow.nameForFile}_${imageType}`;
  const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
  return `${cleanedBaseName}.${extension}`;
}
function extractCleanPath(imagePath) {
  if (!imagePath || imagePath.trim() === "") return "";
  if (!imagePath.startsWith("http")) {
    return imagePath.split("/").pop() || imagePath;
  }
  return imagePath;
}
function isNetworkError(error) {
  if (!error || typeof error !== "object" || typeof error.message !== "string") {
    return false;
  }
  const networkErrors = [
    "ERR_CONNECTION_TIMED_OUT",
    "ERR_NETWORK_CHANGED",
    "ERR_INTERNET_DISCONNECTED",
    "ERR_NAME_NOT_RESOLVED",
    "ERR_CONNECTION_REFUSED",
    "ERR_CONNECTION_RESET",
    "ERR_BLOCKED_BY_CLIENT"
  ];
  return networkErrors.some(
    (errorCode) => error.message.includes(errorCode)
  );
}
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(
        new Error(tWithParams("images.timeout", { timeout: timeoutMs }))
      );
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function downloadImage(url) {
  if (!isValidImageUrl(url)) {
    throw new Error(tWithParams("images.invalidUrl", { url }));
  }
  let lastError = new Error(
    tWithParams("images.downloadFailed", { url })
  );
  for (let attempt = 1; attempt <= DOWNLOAD_CONFIG.maxRetries; attempt++) {
    try {
      const downloadPromise = (0, import_obsidian4.requestUrl)({
        url,
        method: "GET"
      });
      const response = await withTimeout(
        downloadPromise,
        DOWNLOAD_CONFIG.timeout
      );
      if (response.status !== 200) {
        if (response.status === 404) {
          throw new Error(
            tWithParams("images.imageNotFound", { url })
          );
        } else if (response.status === 403) {
          throw new Error(
            tWithParams("images.accessForbidden", { url })
          );
        } else if (response.status >= 500) {
          throw new Error(
            tWithParams("images.serverError", {
              status: response.status,
              url
            })
          );
        } else {
          throw new Error(
            tWithParams("images.httpError", {
              status: response.status,
              url
            })
          );
        }
      }
      return {
        data: response.arrayBuffer,
        mimeType: response.headers["content-type"]
      };
    } catch (error) {
      lastError = error;
      console.warn(
        `Failed to download image (attempt ${attempt}/${DOWNLOAD_CONFIG.maxRetries}): ${url}`,
        error
      );
      if (attempt === DOWNLOAD_CONFIG.maxRetries || !isNetworkError(error)) {
        break;
      }
      if (attempt < DOWNLOAD_CONFIG.maxRetries) {
        await delay(DOWNLOAD_CONFIG.retryDelay);
      }
    }
  }
  console.error(
    `Failed to download image after ${DOWNLOAD_CONFIG.maxRetries} attempts: ${url}`,
    lastError
  );
  throw lastError;
}
async function saveImageToVault(app, imageData, folderPath, fileName) {
  const { vault } = app;
  const normalizedFolderPath = (0, import_obsidian4.normalizePath)(folderPath);
  if (!vault.getAbstractFileByPath(normalizedFolderPath)) {
    await vault.createFolder(normalizedFolderPath);
  }
  const fullPath = (0, import_obsidian4.normalizePath)(`${folderPath}/${fileName}`);
  let finalPath = fullPath;
  let counter = 1;
  while (vault.getAbstractFileByPath(finalPath)) {
    const pathParts = fullPath.split(".");
    const extension = pathParts.pop();
    const basePath = pathParts.join(".");
    finalPath = `${basePath}_${counter}.${extension}`;
    counter++;
  }
  await vault.createBinary(finalPath, imageData);
  return finalPath;
}
async function downloadAndSaveImage(app, url, movieShow, imageType, folderPath) {
  try {
    if (!isValidImageUrl(url)) {
      return url;
    }
    const { data, mimeType } = await downloadImage(url);
    const extension = getImageExtension(url, mimeType);
    const fileName = createImageFileName(movieShow, imageType, extension);
    const localPath = await saveImageToVault(
      app,
      data,
      folderPath,
      fileName
    );
    return localPath;
  } catch (error) {
    console.error(`Failed to download and save image: ${url}`, error);
    throw error;
  }
}
function createImageLink(imagePath) {
  if (!imagePath || imagePath.trim() === "") return [];
  if (!imagePath.startsWith("http")) {
    const fileName = imagePath.split("/").pop() || imagePath;
    return [`![[${fileName}]]`];
  }
  return [`![](${imagePath})`];
}
function countImagesToDownload(movieShow, settings) {
  let count = 0;
  if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0] && isValidImageUrl(movieShow.posterUrl[0])) {
    count++;
  }
  return count;
}
function getImageTypeDisplayName(imageType) {
  return t(`images.${imageType}`);
}
async function processImages(app, movieShow, settings, progressCallback) {
  if (!settings.saveImagesLocally) {
    return movieShow;
  }
  const updatedMovieShow = { ...movieShow };
  const totalImages = countImagesToDownload(movieShow, settings);
  let processedImages = 0;
  let successfulDownloads = 0;
  let failedDownloads = 0;
  if (totalImages === 0) {
    progressCallback == null ? void 0 : progressCallback(0, 0, t("images.noImagesToDownload"));
    return movieShow;
  }
  try {
    if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0]) {
      const posterUrl = movieShow.posterUrl[0];
      if (isValidImageUrl(posterUrl)) {
        const imageTypeName = getImageTypeDisplayName("poster");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            posterUrl,
            movieShow,
            "poster",
            settings.imagesFolder
          );
          updatedMovieShow.posterMarkdown = createImageLink(localPath);
          updatedMovieShow.posterPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download poster image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.posterUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.poster")}`
            );
          }
          updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
          updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
        }
      } else {
        updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
        updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
      }
    }
    if (progressCallback) {
      if (failedDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          tWithParams("images.completedWithErrors", {
            successful: successfulDownloads,
            failed: failedDownloads
          })
        );
      } else if (successfulDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAllDownloaded")
        );
      } else {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAlreadyLocal")
        );
      }
    }
    if (failedDownloads > 0) {
      if (successfulDownloads > 0) {
        new import_obsidian4.Notice(
          tWithParams("images.downloadedWithErrors", {
            successful: successfulDownloads,
            total: totalImages
          })
        );
      } else {
        new import_obsidian4.Notice(t("images.imagesUnavailable"));
      }
    }
  } catch (error) {
    console.error("Error processing images:", error);
    progressCallback == null ? void 0 : progressCallback(
      processedImages,
      totalImages,
      t("images.processingError")
    );
    new import_obsidian4.Notice(t("images.processingError"));
  }
  return updatedMovieShow;
}
var import_obsidian4, DOWNLOAD_CONFIG, SUPPORTED_EXTENSIONS, MIME_TO_EXTENSION_MAP;
var init_imageUtils = __esm({
  "Utils/imageUtils.ts"() {
    import_obsidian4 = require("obsidian");
    init_utils();
    init_i18n();
    DOWNLOAD_CONFIG = {
      timeout: 1e4,
      // 10 seconds timeout
      maxRetries: 2,
      // maximum 2 attempts
      retryDelay: 1e3
      // delay between attempts in ms
    };
    SUPPORTED_EXTENSIONS = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "webp",
      "svg",
      "bmp"
    ];
    MIME_TO_EXTENSION_MAP = {
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp",
      "image/svg+xml": "svg",
      "image/bmp": "bmp"
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianKinopoiskPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// Views/search_modal.ts
var import_obsidian2 = require("obsidian");

// APIProvider/provider.ts
var import_obsidian = require("obsidian");

// APIProvider/ErrorHandler.ts
init_i18n();
var NETWORK_ERROR_PATTERNS = [
  "net::",
  "NetworkError",
  "Failed to fetch",
  "ENOTFOUND",
  "ECONNREFUSED",
  "ETIMEDOUT"
];
var ErrorHandler = class {
  /**
   * Returns localized error message for HTTP status code
   */
  getHttpStatusMessage(status) {
    const statusMessages = {
      400: t("errorHandler.badRequest"),
      401: t("errorHandler.unauthorized"),
      403: t("errorHandler.forbidden"),
      404: t("errorHandler.notFound"),
      429: t("errorHandler.tooManyRequests"),
      500: t("errorHandler.internalServerError"),
      502: t("errorHandler.badGateway"),
      503: t("errorHandler.serviceUnavailable"),
      504: t("errorHandler.gatewayTimeout")
    };
    return statusMessages[status] || "";
  }
  /**
   * Processes API errors and creates user-friendly error messages
   */
  handleApiError(error) {
    const errorDetails = this.extractErrorDetails(error);
    if (errorDetails.isNetworkError) {
      return new Error(t("errorHandler.networkError"));
    }
    const knownMessage = this.getHttpStatusMessage(errorDetails.status);
    if (knownMessage) {
      return new Error(knownMessage);
    }
    if (errorDetails.status > 0) {
      return new Error(
        tWithParams("errorHandler.unknownStatusError", {
          status: errorDetails.status.toString()
        })
      );
    }
    return new Error(t("errorHandler.unexpectedError"));
  }
  /**
   * Extracts error details from various error formats
   */
  extractErrorDetails(error) {
    const details = {
      status: 0,
      message: "",
      isNetworkError: false,
      originalError: error
    };
    if (this.isNetworkError(error)) {
      details.isNetworkError = true;
      return details;
    }
    details.status = this.extractStatusCode(error);
    return details;
  }
  isNetworkError(error) {
    if (!(error instanceof Error)) {
      return false;
    }
    return NETWORK_ERROR_PATTERNS.some(
      (pattern) => error.message.includes(pattern)
    );
  }
  /**
   * Extracts HTTP status code from error object
   */
  extractStatusCode(error) {
    if (!error || typeof error !== "object") {
      return 0;
    }
    if ("status" in error && typeof error.status === "number") {
      return error.status;
    }
    if ("response" in error && error.response && typeof error.response === "object" && "status" in error.response && typeof error.response.status === "number") {
      return error.response.status;
    }
    if ("statusCode" in error && typeof error.statusCode === "number") {
      return error.statusCode;
    }
    return 0;
  }
  logError(context, error) {
    console.error(`[${context}] Error:`, error);
  }
};

// APIProvider/DataFormatter.ts
var MAX_ARRAY_ITEMS = 50;
var MAX_FACTS_COUNT = 5;
var TYPE_TRANSLATIONS = {
  "animated-series": "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0438\u0430\u043B",
  anime: "\u0410\u043D\u0438\u043C\u0435",
  cartoon: "\u041C\u0443\u043B\u044C\u0442\u0444\u0438\u043B\u044C\u043C",
  movie: "\u0424\u0438\u043B\u044C\u043C",
  "tv-series": "\u0421\u0435\u0440\u0438\u0430\u043B"
};
var HTML_ENTITIES = {
  "&laquo;": "\xAB",
  "&raquo;": "\xBB",
  "&ldquo;": '"',
  "&rdquo;": '"',
  "&lsquo;": "'",
  "&rsquo;": "'",
  "&quot;": '"',
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&nbsp;": " ",
  "&ndash;": "\u2013",
  "&mdash;": "\u2014",
  "&hellip;": "\u2026"
};
var DataFormatter = class {
  /**
   * Set settings for path support
   */
  setSettings(settings) {
    this.settings = settings;
  }
  setFetchSpouseDataFunction(fn) {
    this.fetchSpouseDataFn = fn;
  }
  async processSpouses(spouses, movieFolder) {
    if (!spouses || !Array.isArray(spouses) || spouses.length === 0) {
      return [];
    }
    const spouseLinks = [];
    for (const spouse of spouses) {
      if (!spouse) continue;
      if (spouse.name && spouse.name.trim() !== "") {
        const cleanName = this.cleanTextForMetadata(spouse.name);
        if (spouse.id && movieFolder && movieFolder.trim() !== "") {
          spouseLinks.push(`"[[${movieFolder}/${spouse.id}|${cleanName}]]"`);
        } else if (spouse.id) {
          spouseLinks.push(`"[[${spouse.id}|${cleanName}]]"`);
        } else if (movieFolder && movieFolder.trim() !== "") {
          spouseLinks.push(`"[[${movieFolder}/${cleanName}]]"`);
        } else {
          spouseLinks.push(`"[[${cleanName}]]"`);
        }
      } else if (spouse.id && this.fetchSpouseDataFn) {
        try {
          const spouseData = await this.fetchSpouseDataFn(spouse.id);
          if (spouseData.name && spouseData.name.trim() !== "") {
            const cleanName = this.cleanTextForMetadata(spouseData.name);
            if (movieFolder && movieFolder.trim() !== "") {
              spouseLinks.push(`"[[${movieFolder}/${spouse.id}|${cleanName}]]"`);
            } else {
              spouseLinks.push(`"[[${spouse.id}|${cleanName}]]"`);
            }
          }
        } catch (error) {
          console.warn(`Failed to fetch spouse data for id ${spouse.id}:`, error);
        }
      }
    }
    return spouseLinks;
  }
  /**
   * Transforms API data into MovieShow format
   */
  async createMovieShowFrom(fullInfo) {
    var _a, _b, _c, _d, _e, _f, _g;
    const spousesLinks = await this.processSpouses(
      fullInfo.spouses,
      ((_a = this.settings) == null ? void 0 : _a.movieFolder) || ""
    );
    let photoUrl = fullInfo.photo;
    if (photoUrl) {
      photoUrl = photoUrl.replace(/^https:https:\/\//, "https://");
    }
    const item = {
      // Basic information
      id: fullInfo.id,
      sex: fullInfo.sex,
      spouses: spousesLinks,
      birthday: ((_b = fullInfo.birthday) == null ? void 0 : _b.split("T")[0]) || "",
      death: ((_c = fullInfo.death) == null ? void 0 : _c.split("T")[0]) || "",
      age: (_e = (_d = fullInfo.age) == null ? void 0 : _d.toString()) != null ? _e : "",
      growth: (_g = (_f = fullInfo.growth) == null ? void 0 : _f.toString()) != null ? _g : "",
      name: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */),
      description: this.formatArray(
        [fullInfo.description || ""],
        "long" /* LONG_TEXT */
      ),
      nameForFile: this.cleanTextForMetadata(fullInfo.name),
      enNameForFile: this.cleanTextForMetadata(fullInfo.enName || ""),
      // Images
      posterUrl: this.formatArray(
        [photoUrl || ""],
        "url" /* URL */
      ),
      // Ready-to-use image links for Obsidian
      posterMarkdown: this.createImageLink(fullInfo.photo || ""),
      // Clean image paths for template sizing (filled by processImages())
      posterPath: [],
      // External IDs and links
      kinopoiskUrl: this.formatArray(
        [`https://www.kinopoisk.ru/name/${fullInfo.id}/`],
        "url" /* URL */
      ),
      // Alternative names
      enName: this.formatArray(
        [fullInfo.enName || ""],
        "short" /* SHORT_VALUE */
      )
    };
    return item;
  }
  /**
   * Universal array formatting based on type
   */
  formatArray(items, formatType, folderPath, maxItems = MAX_ARRAY_ITEMS) {
    if (formatType === "link_id_with_path" /* LINK_ID_WITH_PATH */) {
      const personItems = items;
      return personItems.filter((item) => item.name && item.name.trim() !== "").slice(0, maxItems).map((item) => {
        const cleanName = this.cleanTextForMetadata(item.name);
        if (folderPath && folderPath.trim() !== "" && item.id) {
          return `"[[${folderPath}/${item.id}|${cleanName}]]"`;
        } else if (item.id) {
          return `"[[${item.id}|${cleanName}]]"`;
        }
        return `"[[${cleanName}]]"`;
      });
    }
    const stringItems = items.map(
      (item) => typeof item === "object" && item.name ? item.name : item
    );
    const filteredItems = stringItems.filter((item) => typeof item === "string" && item.trim() !== "").slice(0, maxItems);
    switch (formatType) {
      case "short" /* SHORT_VALUE */:
        return filteredItems.map(
          (item) => this.cleanTextForMetadata(item)
        );
      case "long" /* LONG_TEXT */:
        return filteredItems.map((item) => {
          const cleanedItem = item.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
          return `"${cleanedItem}"`;
        });
      case "url" /* URL */:
        return filteredItems.map((item) => item.trim());
      case "link" /* LINK */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          return `"[[${cleanName}]]"`;
        });
      case "link_with_path" /* LINK_WITH_PATH */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          if (folderPath && folderPath.trim() !== "") {
            return `"[[${folderPath}/${cleanName}]]"`;
          }
          return `"[[${cleanName}]]"`;
        });
      default:
        return filteredItems;
    }
  }
  /**
   * Calculates seasons data from seasons info
   */
  calculateSeasonsData(seasonsInfo) {
    if (!seasonsInfo || seasonsInfo.length === 0) {
      return { count: 0, averageEpisodesPerSeason: 0 };
    }
    const totalEpisodes = seasonsInfo.reduce(
      (total, season) => total + season.episodesCount,
      0
    );
    const averageEpisodes = Math.ceil(totalEpisodes / seasonsInfo.length);
    return {
      count: seasonsInfo.length,
      averageEpisodesPerSeason: averageEpisodes
    };
  }
  /**
   * Processes facts by removing spoilers and HTML tags
   */
  processFacts(facts) {
    return facts.filter(
      (fact) => !fact.spoiler && fact.value && fact.value.trim() !== ""
    ).slice(0, MAX_FACTS_COUNT).map((fact) => this.stripHtmlTags(fact.value));
  }
  /**
   * Formats date to Obsidian format (YYYY-MM-DD)
   */
  formatDate(dateString) {
    if (!dateString) return "";
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime()) || date.getFullYear() < 1800 || date.getFullYear() > 2100) {
        return "";
      }
      return date.toISOString().split("T")[0];
    } catch (e) {
      return "";
    }
  }
  /**
   * Cleans text from characters that might break metadata
   */
  cleanTextForMetadata(text) {
    if (!text) return "";
    return text.replace(/:/g, "").trim();
  }
  /**
   * Creates image link for Obsidian format
   */
  createImageLink(imagePath) {
    if (!imagePath || imagePath.trim() === "") return [];
    if (!imagePath.startsWith("http")) {
      return [`![[${imagePath}]]`];
    }
    return [`![](${imagePath})`];
  }
  translateType(type) {
    return TYPE_TRANSLATIONS[type] || type;
  }
  /**
   * Removes HTML tags and decodes HTML entities
   */
  stripHtmlTags(text) {
    let cleanText = text.replace(/<[^>]*>/g, "");
    for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
      cleanText = cleanText.replace(new RegExp(entity, "g"), char);
    }
    cleanText = cleanText.replace(/&#?\w+;/g, "");
    return cleanText.trim();
  }
};

// APIProvider/ApiValidator.ts
init_i18n();
var MIN_QUERY_LENGTH = 1;
var MAX_QUERY_LENGTH = 200;
var MIN_TOKEN_LENGTH = 10;
var MAX_TOKEN_LENGTH = 100;
var MIN_MOVIE_ID = 1;
var MAX_MOVIE_ID = 99999999;
var ApiValidator = class {
  /**
   * Validates API token format and length
   */
  isValidToken(token) {
    if (typeof token !== "string") {
      return false;
    }
    const trimmedToken = token.trim();
    if (!trimmedToken) {
      return false;
    }
    if (trimmedToken.length < MIN_TOKEN_LENGTH || trimmedToken.length > MAX_TOKEN_LENGTH) {
      return false;
    }
    const tokenPattern = /^[A-Za-z0-9\-_]+$/;
    if (!tokenPattern.test(trimmedToken)) {
      return false;
    }
    return true;
  }
  /**
   * Validates search query for safety and length
   */
  isValidSearchQuery(query) {
    if (typeof query !== "string") {
      return false;
    }
    const trimmedQuery = query.trim();
    if (!trimmedQuery) {
      return false;
    }
    if (trimmedQuery.length < MIN_QUERY_LENGTH || trimmedQuery.length > MAX_QUERY_LENGTH) {
      return false;
    }
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+=/i,
      /<%/,
      /%>/
    ];
    if (suspiciousPatterns.some((pattern) => pattern.test(trimmedQuery))) {
      return false;
    }
    return true;
  }
  /**
   * Validates movie ID range and type
   */
  isValidMovieId(id) {
    if (typeof id !== "number") {
      return false;
    }
    if (!Number.isFinite(id)) {
      return false;
    }
    if (id < MIN_MOVIE_ID || id > MAX_MOVIE_ID) {
      return false;
    }
    if (!Number.isInteger(id)) {
      return false;
    }
    return true;
  }
  /**
   * Validates pagination parameters
   */
  isValidPaginationParams(page, limit) {
    if (page !== void 0) {
      if (!Number.isInteger(page) || page < 1 || page > 1e3) {
        return false;
      }
    }
    if (limit !== void 0) {
      if (!Number.isInteger(limit) || limit < 1 || limit > 250) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sanitizes search query by removing dangerous characters
   */
  sanitizeQuery(query) {
    return query.trim().replace(/\s+/g, " ").replace(/[<>]/g, "").substring(0, MAX_QUERY_LENGTH);
  }
  /**
   * Sanitizes token by keeping only allowed characters
   */
  sanitizeToken(token) {
    return token.trim().replace(/[^A-Za-z0-9\-_]/g, "").substring(0, MAX_TOKEN_LENGTH);
  }
  /**
   * Validates complete request configuration
   */
  validateRequestConfig(config) {
    const errors = [];
    if (!this.isValidToken(config.token)) {
      errors.push(t("validation.invalidApiToken"));
    }
    if (config.query !== void 0 && !this.isValidSearchQuery(config.query)) {
      errors.push(t("validation.invalidSearchQuery"));
    }
    if (config.movieId !== void 0 && !this.isValidMovieId(config.movieId)) {
      errors.push(t("validation.invalidMovieId"));
    }
    if (!this.isValidPaginationParams(config.page, config.limit)) {
      errors.push(t("validation.invalidPaginationParams"));
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// APIProvider/provider.ts
init_i18n();
var API_BASE_URL = "https://api.kinopoisk.dev/v1.4";
var MAX_SEARCH_RESULTS = 50;
var KinopoiskProvider = class {
  constructor(settings) {
    this.errorHandler = new ErrorHandler();
    this.dataFormatter = new DataFormatter();
    this.validator = new ApiValidator();
    if (settings) {
      this.dataFormatter.setSettings(settings);
    }
    this.dataFormatter.setFetchSpouseDataFunction(
      (id) => this.fetchPersonById(id)
    );
  }
  //   KinopoiskProvider
  updateSettings(settings) {
    this.dataFormatter.setSettings(settings);
  }
  async fetchPersonById(id) {
    const token = this.lastUsedToken || "";
    if (!token) {
      throw new Error("Token not available for spouse data fetch");
    }
    return await this.apiGet(
      `/person/${id}`,
      token
    );
  }
  /**
   * Performs HTTP GET request to API
   */
  async apiGet(endpoint, token, params = {}, headers) {
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequired"));
    }
    const url = this.buildUrl(endpoint, params);
    try {
      const res = await (0, import_obsidian.requestUrl)({
        url,
        method: "GET",
        headers: {
          Accept: "*/*",
          "X-API-KEY": token.trim(),
          ...headers
        }
      });
      return res.json;
    } catch (error) {
      throw this.errorHandler.handleApiError(error);
    }
  }
  /**
   * Builds URL with query parameters
   */
  buildUrl(endpoint, params) {
    const url = new URL(`${API_BASE_URL}${endpoint}`);
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0 && value !== null && value !== "") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url.href;
  }
  /**
   * Search for movies and TV shows by query
   */
  async searchByQuery(query, token) {
    if (!this.validator.isValidSearchQuery(query)) {
      throw new Error(t("provider.enterMovieTitle"));
    }
    const searchResults = await this.apiGet(
      "/person/search",
      token,
      {
        query: query.trim(),
        limit: MAX_SEARCH_RESULTS
      }
    );
    if (!searchResults.docs || searchResults.docs.length === 0) {
      throw new Error(
        tWithParams("provider.nothingFound", { query }) + " " + t("provider.tryChangeQuery")
      );
    }
    return searchResults.docs;
  }
  /**
   * Retrieves detailed movie/TV show information by ID
   */
  async getMovieById(id, token, movieFolder) {
    if (!this.validator.isValidMovieId(id)) {
      throw new Error(t("provider.invalidMovieId"));
    }
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequiredForMovie"));
    }
    this.lastUsedToken = token;
    const movieData = await this.apiGet(
      `/person/${id}`,
      token
    );
    if (!movieData) {
      throw new Error(t("provider.movieInfoError"));
    }
    const movieShow = await this.dataFormatter.createMovieShowFrom(movieData);
    return movieShow;
  }
  /**
   * Validates API token by making test request
   */
  async validateToken(token) {
    if (!this.validator.isValidToken(token)) {
      return false;
    }
    try {
      await this.apiGet("/person", token, {
        page: 1,
        limit: 1
      });
      return true;
    } catch (e) {
      return false;
    }
  }
};
var provider = new KinopoiskProvider();
async function getByQuery(query, token) {
  return provider.searchByQuery(query, token);
}
async function getMovieShowById(id, token, movieFolder) {
  provider.updateSettings({ movieFolder });
  return provider.getMovieById(id, token, movieFolder);
}

// Views/search_modal.ts
init_i18n();
var SearchModal = class extends import_obsidian2.Modal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.callback = callback;
    this.isBusy = false;
    this.query = "";
    this.token = "";
    // Enter key handler for search
    this.submitEnterCallback = (event) => {
      if (event.key === "Enter" && !event.isComposing) {
        this.search();
      }
    };
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider({
      movieFolder: plugin.settings.movieFolder
    });
  }
  // Manages UI loading state
  setBusy(busy) {
    var _a, _b, _c;
    this.isBusy = busy;
    (_a = this.okBtnRef) == null ? void 0 : _a.setDisabled(busy);
    (_b = this.okBtnRef) == null ? void 0 : _b.setButtonText(
      busy ? t("modals.searching") : t("modals.searchButton")
    );
    (_c = this.inputRef) == null ? void 0 : _c.setDisabled(busy);
  }
  // Validates input before search
  validateInput() {
    var _a, _b;
    if (!((_a = this.query) == null ? void 0 : _a.trim())) {
      new import_obsidian2.Notice(t("modals.enterMovieName"));
      return false;
    }
    if (!((_b = this.token) == null ? void 0 : _b.trim())) {
      new import_obsidian2.Notice(t("modals.needApiToken"));
      return false;
    }
    if (this.isBusy) {
      return false;
    }
    return true;
  }
  // Handles search errors
  handleSearchError(error) {
    const errorMessage = error instanceof Error ? error.message : t("modals.errorUnexpected");
    new import_obsidian2.Notice(errorMessage);
    this.callback(error);
  }
  // Performs search via Kinopoisk API
  async search() {
    if (!this.validateInput()) {
      return;
    }
    try {
      this.setBusy(true);
      const searchResults = await this.kinopoiskProvider.searchByQuery(
        this.query.trim(),
        this.token
      );
      this.callback(null, searchResults);
      this.close();
    } catch (error) {
      this.handleSearchError(error);
    } finally {
      this.setBusy(false);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("modals.searchTitle") });
    contentEl.createDiv(
      { cls: "kinopoisk-plugin__search-modal--input" },
      (settingItem) => {
        this.inputRef = new import_obsidian2.TextComponent(settingItem).setValue(this.query).setPlaceholder(t("modals.searchPlaceholder")).onChange((value) => this.query = value);
        this.inputRef.inputEl.addEventListener(
          "keydown",
          this.submitEnterCallback
        );
      }
    );
    new import_obsidian2.Setting(contentEl).addButton((btn) => {
      return this.okBtnRef = btn.setButtonText(t("modals.searchButton")).setCta().onClick(() => {
        this.search();
      });
    });
  }
  onClose() {
    var _a;
    if ((_a = this.inputRef) == null ? void 0 : _a.inputEl) {
      this.inputRef.inputEl.removeEventListener(
        "keydown",
        this.submitEnterCallback
      );
    }
    this.contentEl.empty();
  }
};

// Views/suggest_modal.ts
var import_obsidian5 = require("obsidian");
init_imageUtils();
init_i18n();
var ItemsSuggestModal = class extends import_obsidian5.SuggestModal {
  constructor(plugin, suggestion, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestion = suggestion;
    this.onChoose = onChoose;
    this.token = "";
    this.token = plugin.settings.apiToken;
    this.kinopoiskProvider = new KinopoiskProvider({
      movieFolder: plugin.settings.movieFolder
    });
  }
  // Filters suggestions by search query
  getSuggestions(query) {
    return this.suggestion.filter((item) => {
      const searchQuery = query == null ? void 0 : query.toLowerCase();
      return item.name.toLowerCase().includes(searchQuery) || item.enName.toLowerCase().includes(searchQuery);
    });
  }
  // Validates image URL
  isValidImageUrl(url) {
    if (!url || url.trim() === "") return false;
    try {
      new URL(url);
      return url.startsWith("http://") || url.startsWith("https://");
    } catch (e) {
      return false;
    }
  }
  // Creates poster image element or placeholder
  createPosterElement(item, container) {
    const posterUrl = item.photo;
    if (this.isValidImageUrl(posterUrl)) {
      const imgElement = container.createEl("img", {
        cls: "kinopoisk-plugin__suggest-poster"
      });
      imgElement.src = posterUrl;
      imgElement.addEventListener("error", () => {
        const placeholder = container.createEl("div", {
          text: t("modals.posterPlaceholderEmoji"),
          cls: "kinopoisk-plugin__suggest-poster-placeholder"
        });
        placeholder.title = t("modals.posterTooltipGeoblock");
        imgElement.replaceWith(placeholder);
      });
      return imgElement;
    } else {
      const placeholder = container.createEl("div", {
        text: t("modals.posterPlaceholderEmoji"),
        cls: "kinopoisk-plugin__suggest-poster-placeholder"
      });
      const reason = !posterUrl ? t("modals.posterTooltipMissing") : posterUrl.trim() === "" ? t("modals.posterTooltipEmptyLink") : t("modals.posterTooltipInvalidLink");
      placeholder.title = reason;
      return placeholder;
    }
  }
  // Renders list item with poster and movie info
  renderSuggestion(item, el) {
    const title = item.name;
    const subtitle = `\u0412\u043E\u0437\u0440\u0430\u0441\u0442: ${item.age}, \u0420\u043E\u0441\u0442: ${item.growth}, \u041F\u043E\u043B: ${item.sex}`;
    const container = el.createEl("div", {
      cls: "kinopoisk-plugin__suggest-item"
    });
    this.createPosterElement(item, container);
    const textInfo = container.createEl("div", {
      cls: "kinopoisk-plugin__suggest-text-info"
    });
    textInfo.appendChild(el.createEl("div", { text: title }));
    textInfo.appendChild(el.createEl("small", { text: subtitle }));
  }
  // Handles item selection
  onChooseSuggestion(item) {
    this.getItemDetails(item);
  }
  // Manages loading notice display
  updateStatus(message, persistent = true) {
    this.hideLoadingNotice();
    this.loadingNotice = new import_obsidian5.Notice(message, persistent ? 0 : 3e3);
  }
  // Hides loading notice
  hideLoadingNotice() {
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = void 0;
    }
  }
  // Updates existing loading notice text
  updateLoadingNotice(message) {
    if (this.loadingNotice) {
      const noticeEl = this.loadingNotice.noticeEl;
      if (noticeEl) {
        noticeEl.textContent = message;
      }
    } else {
      this.updateStatus(message);
    }
  }
  // Creates progress text with percentage
  createProgressText(current, total, task) {
    if (total === 0) return task;
    const percentage = Math.round(current / total * 100);
    const progressBar = this.createProgressBar(current, total);
    return `${task}
${progressBar} ${current}/${total} (${percentage}%)`;
  }
  // Creates visual progress bar from characters
  createProgressBar(current, total, length = 20) {
    if (total === 0) return "";
    const filled = Math.round(current / total * length);
    const empty = length - filled;
    return "\u2588".repeat(filled) + "\u2591".repeat(empty);
  }
  // Validates input data
  validateInput(item) {
    var _a;
    if (!(item == null ? void 0 : item.id) || item.id <= 0) {
      new import_obsidian5.Notice(t("modals.errorMovieData"));
      this.onChoose(new Error(t("modals.errorMovieData")));
      return false;
    }
    if (!((_a = this.token) == null ? void 0 : _a.trim())) {
      new import_obsidian5.Notice(t("modals.needApiToken"));
      this.onChoose(new Error(t("modals.needApiToken")));
      return false;
    }
    return true;
  }
  // Fetches movie data via API
  async fetchMovieData(itemId) {
    return await this.kinopoiskProvider.getMovieById(itemId, this.token, this.plugin.settings.movieFolder);
  }
  // Processes movie images with progress tracking
  async processMovieImages(movieShow) {
    this.updateLoadingNotice(t("modals.preparingImages"));
    let imageProcessingCompleted = false;
    const progressCallback = (current, total, currentTask) => {
      const progressText = this.createProgressText(
        current,
        total,
        currentTask
      );
      this.updateLoadingNotice(progressText);
      if (current === total) {
        imageProcessingCompleted = true;
      }
    };
    const processedMovieShow = await processImages(
      this.plugin.app,
      movieShow,
      this.plugin.settings,
      progressCallback
    );
    if (imageProcessingCompleted) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
    return processedMovieShow;
  }
  // Handles successful data retrieval
  handleSuccess(movieShow, hadImageProcessing = false) {
    this.hideLoadingNotice();
    if (!hadImageProcessing) {
      new import_obsidian5.Notice(t("modals.movieInfoLoaded"));
    }
    this.onChoose(null, movieShow);
  }
  // Handles errors during data retrieval
  handleError(error) {
    this.hideLoadingNotice();
    const errorMessage = error instanceof Error ? error.message : t("modals.errorGettingDetails");
    new import_obsidian5.Notice(errorMessage);
    console.error("Error getting movie details:", error);
    this.onChoose(error);
  }
  // Fetches detailed movie information with image processing and progress tracking
  async getItemDetails(item) {
    if (!this.validateInput(item)) {
      return;
    }
    try {
      this.updateStatus(t("modals.loadingMovieInfo"));
      const movieShow = await this.fetchMovieData(item.id);
      if (!this.plugin.settings.saveImagesLocally) {
        this.handleSuccess(movieShow, false);
        return;
      }
      const processedMovieShow = await this.processMovieImages(movieShow);
      this.handleSuccess(processedMovieShow, true);
    } catch (error) {
      this.handleError(error);
    }
  }
  // Clean up notices on close
  onClose() {
    this.hideLoadingNotice();
    super.onClose();
  }
};

// Settings/settings.ts
var import_obsidian8 = require("obsidian");

// Settings/Suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");
init_i18n();
var FolderSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFolder) {
    super(app, textInputEl);
    this.onSelectFolder = onSelectFolder;
  }
  /**
   * Get folders matching input text
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const folders = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((folder) => {
        if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().includes(lowerCaseInputStr)) {
          folders.push(folder);
        }
      });
      return folders.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.folderListError"), error);
      return [];
    }
  }
  renderSuggestion(folder, el) {
    if (folder && el) {
      el.setText(folder.path);
    }
  }
  selectSuggestion(folder) {
    if (folder && folder.path) {
      this.setValue(folder.path);
      this.onSelectFolder(folder.path);
      this.close();
    }
  }
};

// Settings/Suggesters/FileSuggester.ts
var import_obsidian7 = require("obsidian");
init_i18n();
var FileSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFile) {
    super(app, textInputEl);
    this.onSelectFile = onSelectFile;
  }
  /**
   * Get files matching input text - filters only .md files
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const files = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((file) => {
        if (file instanceof import_obsidian7.TFile && file.extension === "md" && file.path.toLowerCase().includes(lowerCaseInputStr)) {
          files.push(file);
        }
      });
      return files.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.fileListError"), error);
      return [];
    }
  }
  renderSuggestion(file, el) {
    if (file && el) {
      el.setText(file.path);
    }
  }
  selectSuggestion(file) {
    if (file && file.path) {
      this.setValue(file.path);
      this.onSelectFile(file.path);
      this.close();
    }
  }
};

// Settings/settings.ts
init_i18n();
var docUrl = "https://github.com/2PleXXX/obsidian-kinopoisk-search-plus-plugin";
var apiSite = "https://kinopoisk.dev/";
var DEFAULT_SETTINGS = {
  language: "en",
  apiToken: "",
  apiTokenValid: false,
  movieFileNameFormat: "",
  movieFolder: "",
  movieTemplateFile: "",
  // Image defaults
  imagesFolder: "attachments/kinopoisk",
  saveImagesLocally: false,
  savePosterImage: true,
  autoFillOnCreate: true
};
var ObsidianKinopoiskSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.validationTimeout = null;
    this.kinopoiskProvider = new KinopoiskProvider();
    setLanguage(this.plugin.settings.language);
  }
  get settings() {
    return this.plugin.settings;
  }
  onClose() {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }
  }
  /**
   * Update token validation visual indicator
   */
  updateTokenValidationIndicator(inputElement, isValid) {
    if (!inputElement) return;
    inputElement.removeClass(
      "kinopoisk-plugin__token-valid",
      "kinopoisk-plugin__token-invalid",
      "kinopoisk-plugin__token-checking"
    );
    if (this.plugin.settings.apiToken.trim() !== "") {
      if (isValid === null) {
        inputElement.addClass("kinopoisk-plugin__token-checking");
      } else if (isValid) {
        inputElement.addClass("kinopoisk-plugin__token-valid");
      } else {
        inputElement.addClass("kinopoisk-plugin__token-invalid");
      }
    }
  }
  /**
   * Validate token with delay
   */
  async validateTokenWithDelay(token, inputElement) {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
    }
    this.updateTokenValidationIndicator(inputElement, null);
    this.validationTimeout = setTimeout(async () => {
      try {
        const isValid = await this.kinopoiskProvider.validateToken(
          token
        );
        this.plugin.settings.apiTokenValid = isValid;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, isValid);
      } catch (error) {
        console.error("Token validation error:", error);
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, false);
      }
    }, 1500);
  }
  /**
   * Create folder selection setting
   */
  createFolderSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FolderSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FolderSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  /**
   * Create template file selection setting
   */
  createTemplateSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian8.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FileSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FileSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("obsidian-kinopoisk-plugin__settings");
    new import_obsidian8.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const languages = getSupportedLanguages();
      languages.forEach((lang) => {
        dropdown.addOption(lang.code, lang.name);
      });
      dropdown.setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        setLanguage(value);
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const apiKeyDesc = document.createDocumentFragment();
    apiKeyDesc.createDiv({
      text: t("settings.apiTokenDesc")
    });
    apiKeyDesc.createEl("a", {
      text: t("settings.getApiToken"),
      href: apiSite
    });
    let tokenInputElement;
    new import_obsidian8.Setting(containerEl).setName(t("settings.apiToken")).setDesc(apiKeyDesc).addText((text) => {
      const textComponent = text.setPlaceholder(t("settings.enterToken")).setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value.trim();
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        if (value.trim() !== "") {
          await this.validateTokenWithDelay(
            value.trim(),
            textComponent.inputEl
          );
        } else {
          if (this.validationTimeout) {
            clearTimeout(this.validationTimeout);
            this.validationTimeout = null;
          }
          this.updateTokenValidationIndicator(
            textComponent.inputEl,
            false
          );
        }
      });
      tokenInputElement = textComponent.inputEl;
      if (this.plugin.settings.apiToken.trim() !== "") {
        this.updateTokenValidationIndicator(
          textComponent.inputEl,
          this.plugin.settings.apiTokenValid
        );
      }
      return textComponent;
    }).addButton(
      (button) => button.setButtonText(t("settings.checkToken")).setCta().onClick(async () => {
        const token = this.plugin.settings.apiToken.trim();
        if (!token) {
          new import_obsidian8.Notice(t("settings.enterToken"));
          return;
        }
        button.setDisabled(true);
        button.setButtonText(t("settings.checking"));
        try {
          new import_obsidian8.Notice(t("settings.checking"));
          const isValid = await this.kinopoiskProvider.validateToken(
            token
          );
          this.plugin.settings.apiTokenValid = isValid;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            isValid
          );
          new import_obsidian8.Notice(
            isValid ? t("settings.tokenValid") : t("settings.tokenInvalid")
          );
        } catch (error) {
          console.error(
            "Manual token validation error:",
            error
          );
          this.plugin.settings.apiTokenValid = false;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            false
          );
          new import_obsidian8.Notice(t("settings.tokenError"));
        } finally {
          button.setDisabled(false);
          button.setButtonText(t("settings.checkToken"));
        }
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.imagesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.saveImagesLocally")).setDesc(t("settings.saveImagesLocallyDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveImagesLocally).onChange(async (value) => {
        this.plugin.settings.saveImagesLocally = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.saveImagesLocally) {
      this.createFolderSetting(
        containerEl,
        t("settings.imagesFolder"),
        t("settings.imagesFolderDesc"),
        t("settings.imagesFolderPlaceholder"),
        this.plugin.settings.imagesFolder,
        async (folder) => {
          this.plugin.settings.imagesFolder = folder;
          await this.plugin.saveSettings();
        }
      );
      new import_obsidian8.Setting(containerEl).setName(t("settings.savePosterImage")).setDesc(t("settings.savePosterImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.savePosterImage).onChange(async (value) => {
          this.plugin.settings.savePosterImage = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian8.Setting(containerEl).setName(t("settings.moviesHeading")).setHeading();
    new import_obsidian8.Setting(containerEl).setName(t("settings.movieFileName")).setDesc(t("settings.movieFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.movieFileNamePlaceholder")).setValue(this.plugin.settings.movieFileNameFormat).onChange(async (value) => {
        this.plugin.settings.movieFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.movieFileLocation"),
      t("settings.movieFileLocationDesc"),
      t("settings.movieFileLocationPlaceholder"),
      this.plugin.settings.movieFolder,
      async (folder) => {
        this.plugin.settings.movieFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const movieTemplateFileDesc = document.createDocumentFragment();
    movieTemplateFileDesc.createDiv({
      text: t("settings.movieTemplateFileDesc")
    });
    movieTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.movieTemplateFile"),
      movieTemplateFileDesc,
      t("settings.movieTemplateFilePlaceholder"),
      this.plugin.settings.movieTemplateFile,
      async (file) => {
        this.plugin.settings.movieTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.OnFileCreatedTrigerName")).setDesc(t("settings.OnFileCreatedTrigerDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoFillOnCreate).onChange(async (value) => {
        this.plugin.settings.autoFillOnCreate = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
init_utils();

// Utils/cursor_jumper.ts
var import_obsidian9 = require("obsidian");
var CursorJumper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Move cursor to the beginning of active document
   */
  async jumpToNextCursorLocation() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      if (!(activeView == null ? void 0 : activeView.file)) {
        return;
      }
      const editor = activeView.editor;
      if (!editor) {
        return;
      }
      editor.focus();
      editor.setCursor(0, 0);
    } catch (error) {
      console.error("Error moving cursor:", error);
    }
  }
};

// main.ts
init_i18n();
var ObsidianKinopoiskPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    initializeLanguage(this.settings.language);
    this.addRibbonIcon("circle-user-round", "Search in Kinopoisk actors", () => {
      this.createNewNote();
    });
    this.addCommand({
      id: "open-search-kinopoisk-modal",
      name: "Search",
      callback: () => {
        this.createNewNote();
      }
    });
    this.addCommand({
      id: "search-current-actor-name",
      name: "Search by current actor name",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (activeView) {
          if (!checking) {
            this.searchByCurrentActorName();
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian10.TFile) {
          this.onFileCreated(file);
        }
      })
    );
    this.addSettingTab(new ObsidianKinopoiskSettingTab(this.app, this));
  }
  // Shows error notification to user
  showNotice(error) {
    try {
      new import_obsidian10.Notice(error.message);
    } catch (e) {
    }
  }
  async onFileCreated(file) {
    if (!this.settings.autoFillOnCreate) {
      return;
    }
    if (file.extension !== "md") {
      return;
    }
    const movieFolder = this.settings.movieFolder;
    if (!movieFolder || !file.path.startsWith(movieFolder)) {
      return;
    }
    const content = await this.app.vault.read(file);
    if (content.trim().length > 10) {
      return;
    }
    const searchQuery = file.basename;
    setTimeout(async () => {
      try {
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(file);
        const isNumericId = /^\d+$/.test(searchQuery.trim());
        let selectedActor;
        if (isNumericId) {
          const actorId = parseInt(searchQuery.trim());
          new import_obsidian10.Notice(`Fetching actor by ID: ${actorId}`);
          try {
            selectedActor = await getMovieShowById(
              actorId,
              this.settings.apiToken,
              this.settings.movieFolder
            );
          } catch (error) {
            console.error("Error fetching by ID:", error);
            new import_obsidian10.Notice(`Failed to fetch actor with ID ${actorId}`);
            return;
          }
        } else {
          new import_obsidian10.Notice(`Searching for: ${searchQuery}`);
          const searchResults = await getByQuery(searchQuery, this.settings.apiToken);
          if (!(searchResults == null ? void 0 : searchResults.length)) {
            new import_obsidian10.Notice(`No results found for "${searchQuery}"`);
            return;
          }
          selectedActor = await this.openSuggestModal(searchResults);
        }
        if (this.settings.saveImagesLocally) {
          new import_obsidian10.Notice("Processing images...");
          const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
          selectedActor = await processImages2(
            this.app,
            selectedActor,
            this.settings,
            (current, total, task) => {
              console.log(`Image processing: ${current}/${total} - ${task}`);
            }
          );
        }
        const renderedContents = await this.getRenderedContents(selectedActor);
        await this.app.vault.modify(file, renderedContents);
        const activeLeaf = this.app.workspace.getLeaf(false);
        await activeLeaf.openFile(file, { state: { mode: "preview" } });
        new import_obsidian10.Notice("Actor data added successfully!");
      } catch (err) {
        console.warn("Error auto-filling actor file:", err);
        if (err instanceof Error) {
          this.showNotice(err);
        }
      }
    }, 300);
  }
  async searchByCurrentActorName() {
    var _a, _b;
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (!activeView || !activeView.file) {
        new import_obsidian10.Notice("No active file");
        return;
      }
      const currentFile = activeView.file;
      const cache = this.app.metadataCache.getFileCache(activeView.file);
      let searchQuery = "";
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.name) {
        searchQuery = cache.frontmatter.name;
      } else if ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.enName) {
        searchQuery = cache.frontmatter.enName;
      } else {
        searchQuery = activeView.file.basename;
      }
      if (!searchQuery) {
        new import_obsidian10.Notice("Cannot extract actor name from current file");
        return;
      }
      const isNumericId = /^\d+$/.test(searchQuery.trim());
      let selectedActor;
      if (isNumericId) {
        const actorId = parseInt(searchQuery.trim());
        new import_obsidian10.Notice(`Fetching actor by ID: ${actorId}`);
        try {
          selectedActor = await getMovieShowById(
            actorId,
            this.settings.apiToken,
            this.settings.movieFolder
          );
        } catch (error) {
          console.error("Error fetching by ID:", error);
          new import_obsidian10.Notice(`Failed to fetch actor with ID ${actorId}`);
          return;
        }
      } else {
        new import_obsidian10.Notice(`Searching for: ${searchQuery}`);
        try {
          const searchResults = await getByQuery(searchQuery, this.settings.apiToken);
          if (!(searchResults == null ? void 0 : searchResults.length)) {
            new import_obsidian10.Notice(`No results found for "${searchQuery}"`);
            return;
          }
          selectedActor = await this.openSuggestModal(searchResults);
        } catch (error) {
          console.error("Error searching:", error);
          new import_obsidian10.Notice(`Search failed for "${searchQuery}"`);
          return;
        }
      }
      const renderedContents = await this.getRenderedContents(selectedActor);
      await this.app.vault.modify(currentFile, renderedContents);
      new import_obsidian10.Notice("Actor data added successfully!");
    } catch (err) {
      console.error("Error in searchByCurrentActorName:", err);
      this.showNotice(err instanceof Error ? err : new Error("Unknown error"));
    }
  }
  // Main workflow: search -> select -> create note with template
  async createNewNote() {
    try {
      const movieShow = await this.searchMovieShow();
      const {
        movieFileNameFormat,
        movieFolder
      } = this.settings;
      const renderedContents = await this.getRenderedContents(movieShow);
      const fileNameFormat = movieFileNameFormat;
      const folderPath = movieFolder;
      if (folderPath && !await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const fileName = await makeFileName(
        this.app,
        movieShow,
        fileNameFormat,
        folderPath
      );
      const filePath = `${folderPath}/${fileName}`;
      const targetFile = await this.app.vault.create(
        filePath,
        renderedContents
      );
      const newLeaf = this.app.workspace.getLeaf(true);
      if (!newLeaf) {
        console.warn("No new leaf");
        return;
      }
      await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
      newLeaf.setEphemeralState({ rename: "all" });
      await new CursorJumper(this.app).jumpToNextCursorLocation();
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Coordinates search process: search then select from results
  async searchMovieShow() {
    const searchedItems = await this.openSearchModal();
    return await this.openSuggestModal(searchedItems);
  }
  // Opens search modal and returns found items
  async openSearchModal() {
    return new Promise((resolve, reject) => {
      return new SearchModal(this, (error, results) => {
        return error ? reject(error) : resolve(results != null ? results : []);
      }).open();
    });
  }
  // Opens suggestion modal and returns detailed info about selected item
  async openSuggestModal(items) {
    return new Promise((resolve, reject) => {
      return new ItemsSuggestModal(this, items, (error, selectedItem) => {
        return error ? reject(error) : resolve(selectedItem);
      }).open();
    });
  }
  // Loads template content and fills it with movie/series data
  async getRenderedContents(movieShow) {
    const { movieTemplateFile } = this.settings;
    const templateFile = movieTemplateFile;
    if (templateFile) {
      const templateContents = await getTemplateContents(
        this.app,
        templateFile
      );
      const replacedVariable = replaceVariableSyntax(
        movieShow,
        templateContents
      );
      return replacedVariable;
    }
    return "";
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
